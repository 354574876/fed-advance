## 性能优化

### 内存管理
内存：由可读写的单元组成，表示一片可操作空间  
管理：认为去申请，使用和释放一片空间  
内存管理：开发者主动申请、使用释放空间  
管理流程：申请--使用--释放  

#### JavaScript中的垃圾回收
```js
// 申请
let user = {name: 'jj'}
// 使用
console.log(user.name)
// 释放
user = null
```

#### GC算法介绍
**定义：**
* GC 是一种机制，垃圾回收完成具体的工作
* GC 可以找到内存中的垃圾、并释放和回收空间  
* 算法就是工作时查找和回收所遵循的规则

**GC中的垃圾是什么：**
* 程序中不再需要使用的对象
* 程序中不能再访问到的对象

**常见的GC算法：**
* 引用计数  
  根据当前代码执行完成之后，计算变量是否有被引用，如果引用标记为0，那么会被释放掉；优点：及时回收，减少卡顿；缺点：时间开销大（实时计算），无法回收循环引用的对象
* 标记清除
  分标记和清除：1.遍历所有对象标记活动对象，2.遍历所有对象清除没有标记对象，3.回收相应的空间；优点：能够解决引用计算中循环引用的问题；缺点：空间碎片化，不能让空间最大使用，不会立即清除垃圾
* 标记整理
  标记清除的增强，优化了空间碎片化；缺点：不能立即清除
* 分代回收  


### V8

* 主流的JavaScript执行引擎
* 即时编译
* 内存设限（64，1.5G上线；32位，800M）  

#### 回收策略
分代回收：**新生代、老生代**

V8中的常用GC算法
* 分代回收
* 空间复制
* 标记清除
* 标记整理
* 标记增量


**V8 内存分配**
* V8内存空间一分为二
* 小空间用于存储新生代对象（32M｜16M）
* 新生代指的是存活时间较短的对象  

新生代对象回收实现：
回收过程采用复制算法+标记整理 -> 新生代内存区分为二个等大小空间：From（使用空间），To（空闲空间） -> 活动对象存储分于 From空间 -> 标记整理后将活动对象拷贝至To -> From 于 To 交换空间完成释放

老年代对象回收实现：  
主要采用标记清除、标记整理、增量标记算法；


### 内存问题体现
* 页面延迟加载或者经常暂停
* 页面持续性出现糟糕的性能
* 页面的性能随着时间延长越来越差（内存泄漏）

#### 监控内存的几种方式
**分析**
* 内存泄漏： 内存使用持续升高
* 内存膨胀：在多数设备上存在性能问题（通过常用设备运行，如果都不OK，就是应用的问题）
* 频繁的垃圾回收：通过内存变化图来分析  

**监控**
* 浏览器任务管理器
* Timeline时序图记录
* 堆块照查找分离DOM
* 判断是否存在频繁的垃圾回收